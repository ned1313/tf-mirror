# Default values for terraform-mirror
# This is a YAML-formatted file.

replicaCount: 1

image:
  repository: terraform-mirror
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use
  name: ""

podAnnotations: {}

podSecurityContext:
  fsGroup: 1000

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false

# Terraform Mirror configuration
config:
  server:
    port: "8080"
    hostname: "0.0.0.0"
  
  storage:
    # Storage type: "local" or "s3"
    type: "s3"
    # Local storage path (used when type is "local")
    localPath: "/data/providers"
    # S3 configuration (used when type is "s3")
    s3:
      endpoint: ""
      bucket: "terraform-mirror"
      region: "us-east-1"
      usePathStyle: true
  
  database:
    path: "/data/mirror.db"
    backupEnabled: false
    backupIntervalHours: 6
    backupToS3: false
    backupS3Prefix: "backups/"
  
  cache:
    enabled: true
    memoryMB: 256
    ttlMinutes: 60
    diskEnabled: true
    diskPath: "/data/cache"
    diskMaxMB: 4096
    diskTtlMinutes: 1440
  
  features:
    multiPlatform: true
    enableAdmin: true
  
  auth:
    tokenExpiry: "24h"
  
  processor:
    enabled: true
    workers: 4
    downloadTimeout: "15m"
    retryAttempts: 3
    retryDelay: "30s"
  
  logging:
    level: "info"
    format: "json"
  
  telemetry:
    enabled: false
    prometheusPath: "/metrics"

# Secrets configuration
secrets:
  # JWT secret for authentication (required, minimum 32 characters)
  jwtSecret: ""
  # S3 credentials (required when storage.type is "s3")
  s3AccessKey: ""
  s3SecretKey: ""
  # Use existing secret instead of creating one
  existingSecret: ""
  # Keys in existing secret
  existingSecretKeys:
    jwtSecret: "jwt-secret"
    s3AccessKey: "s3-access-key"
    s3SecretKey: "s3-secret-key"

# Admin user configuration
admin:
  # Create admin user on install
  createUser: true
  username: "admin"
  # Password for admin user (required if createUser is true)
  password: ""

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # cert-manager.io/cluster-issuer: letsencrypt-prod
    # nginx.ingress.kubernetes.io/proxy-body-size: "500m"
  hosts:
    - host: terraform-mirror.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: terraform-mirror-tls
  #    hosts:
  #      - terraform-mirror.local

resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "1Gi"
    cpu: "1000m"

# Persistence for database and cache
persistence:
  enabled: true
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 20Gi
  annotations: {}

# Liveness and readiness probes
livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

nodeSelector: {}

tolerations: []

affinity: {}

# MinIO subchart configuration (optional)
minio:
  enabled: false
  # MinIO configuration when enabled
  mode: standalone
  persistence:
    enabled: true
    size: 50Gi
  rootUser: "minioadmin"
  rootPassword: "minioadmin"
  buckets:
    - name: terraform-mirror
      policy: none
      purge: false
  resources:
    requests:
      memory: 256Mi
      cpu: 100m
    limits:
      memory: 1Gi
      cpu: 500m
